import argparse
import requests
import json
import sys
import time
import random 

FIREBASE_API_KEY = "AIzaSyAdY2qq9083amKDS0R8tn2tjIKQB8mocco"

API_ENDPOINTS = {
    "login": f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={FIREBASE_API_KEY}",
    "signup": f"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key={FIREBASE_API_KEY}",
    "update": "https://us-central1-webgltest-17af1.cloudfunctions.net/roundCompleteMulti", 
}

def get_token(email, password, signup=False):
    """Handles login or signup to get the user token with minimal output."""
    url = API_ENDPOINTS["signup"] if signup else API_ENDPOINTS["login"]
    
    payload = {
        "email": email,
        "password": password,
        "returnSecureToken": True
    }
    
    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if signup:
             print("\n--- NEW USER SIGNUP SUCCESSFUL ---")
             print(f"Email: {email}")
             print("----------------------------------")
        else:
             print("\nLogin successful.")

        return data.get('idToken')
    except requests.exceptions.HTTPError as e:
        status = e.response.status_code
        try:
            message = e.response.json().get('error', {}).get('message', 'Unknown error')
        except json.JSONDecodeError:
            message = e.response.text
        action = "Signup" if signup else "Login"
        print(f"\n[ERROR] {action} failed. Status: {status}. Reason: {message}")
        sys.exit(1)
    except requests.exceptions.RequestException as e:
        print(f"\n[ERROR] Connection error during authentication: {e}")
        sys.exit(1)

def update_stats(token, kills, deaths, coins, xp, numGames):
    """
    Updates user statistics using the auth token.
    Returns True on success, False on a retryable error.
    """
    if not token:
        print("[ERROR] Cannot update stats: Authentication token is missing.")
        return False
    
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "data": {
            "kills": kills, "deaths": deaths, "coins": coins,
            "xp": xp, "numGames": numGames
        }
    }
    
    url = API_ENDPOINTS["update"]
    
    try:
        response = requests.post(url, headers=headers, json=payload, timeout=15)
        response.raise_for_status()
        
        data = response.json()
        result_data = data.get("result", {})

        is_rate_limited = (
            result_data.get("result") is False and
            "Rate limit exceeded" in result_data.get("message", "")
        )
        
        if is_rate_limited:
            print(f"\n[RATE-LIMIT] Server responded with rate limit. Retrying...")
            return False # Retryable server-side error

        if result_data.get("result") is False:
            print(f"[ERROR] Stats update failed on the server side: {result_data.get('message', 'Unspecified function error')}")
            return False # Treat other function errors as retryable
            
        return True # Success
    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 429 or status_code >= 500:
            return False # Retryable HTTP error (Rate limit or Server Error)
        else:
            print(f"\n[ERROR] An unrecoverable HTTP error occurred (Status: {status_code}). Response: {e.response.text}")
            sys.exit(1)
            
    except requests.exceptions.RequestException as e:
        print(f"\n[ERROR] Connection error during stats update: {e}")
        return False # Retryable connection error

def main():
    parser = argparse.ArgumentParser(
        description="Minimal CLI utility for game stats authentication and update.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    
    auth_group = parser.add_argument_group('Authentication Options (Required)')
    auth_group.add_argument('-e', '--email', type=str, help='Email address.')
    auth_group.add_argument('-p', '--password', type=str, help='Password.')
    auth_group.add_argument('--token', type=str, help='Authentication token.')
    auth_group.add_argument('-s', '--signup', action='store_true',
                            help='Perform signup instead of login.')

    action_group = parser.add_argument_group('Action Flag')
    action_group.add_argument('--update', action='store_true', 
                              help='Flag to initiate the stats update action.')

    stats_group = parser.add_argument_group('Stats (used with --update)')
    stats_group.add_argument('--coins', type=int, default=0, help='Total Coins to add (batched in 2000 increments, default: 0)')
    stats_group.add_argument('--xp', type=int, default=0, help='Total XP to add (batched in 2000 increments, default: 0)')
    
    args = parser.parse_args()
    
    FIXED_KILLS = 11
    FIXED_DEATHS = 10
    FIXED_NUM_GAMES = 42

    token = None
    if args.token:
        token = args.token
        print("\nUsing provided token for authentication.")
    elif args.email and args.password:
        token = get_token(args.email, args.password, args.signup)
    else:
        print("\n[ERROR] Please provide either a token (--token) or email/password (-e/-p).")
        sys.exit(1)

    # 2. Perform Update action
    if args.update and token:
        XP_BATCH_SIZE = 2000
        COINS_BATCH_SIZE = 2000
        
        total_xp_target = args.xp
        total_coins_target = args.coins
        
        num_xp_batches = (total_xp_target + XP_BATCH_SIZE - 1) // XP_BATCH_SIZE if total_xp_target > 0 else 0
        num_coin_batches = (total_coins_target + COINS_BATCH_SIZE - 1) // COINS_BATCH_SIZE if total_coins_target > 0 else 0
        
        num_requests = max(num_xp_batches, num_coin_batches)

        if num_requests == 0:
            print("\n[INFO] XP and Coins targets are 0. No update requests sent.")
            return

        xp_gained = 0
        coins_gained = 0
        delay = 5
        max_delay = 300
        request_count = 0
        
        print(f"\nStarting batched update: Target XP={total_xp_target}, Target Coins={total_coins_target}")
        print(f"Total batches required: {num_requests}")
        
        while request_count < num_requests:
            
            # Inner loop calculates the payload for the current request
            xp_remaining = total_xp_target - xp_gained
            coins_remaining = total_coins_target - coins_gained
            
            xp_to_add = min(XP_BATCH_SIZE, xp_remaining)
            coins_to_add = min(COINS_BATCH_SIZE, coins_remaining)
            
            # Safety check, although shouldn't be needed if logic is correct
            if xp_to_add <= 0 and coins_to_add <= 0:
                 break
            
            print(f"\n--- Attempting Request {request_count + 1}/{num_requests} ---")
            print(f"Sending: XP={xp_to_add}, Coins={coins_to_add}. Kills={FIXED_KILLS}, Deaths={FIXED_DEATHS}, Games={FIXED_NUM_GAMES}")

            # Using fixed values for stats no longer passed via CLI
            success = update_stats(token, FIXED_KILLS, FIXED_DEATHS, coins_to_add, xp_to_add, FIXED_NUM_GAMES)
            
            if success:
                xp_gained += xp_to_add
                coins_gained += coins_to_add
                request_count += 1
                
                print(f"Success. Current Totals: XP={xp_gained}/{total_xp_target}, Coins={coins_gained}/{total_coins_target}")
                delay = 5 # Reset delay on successful request
                if request_count < num_requests:
                    time.sleep(delay)
            else:
                # Retry logic triggered on failure
                delay = min(delay * 2, max_delay)
                jitter = random.uniform(0, delay / 4)
                wait_time = delay + jitter
                
                print(f"Waiting {wait_time:.0f} seconds before retrying Request {request_count + 1}...")
                time.sleep(wait_time)

        if request_count == num_requests:
             print(f"\nFinished. Successfully gained a total of {xp_gained} XP and {coins_gained} Coins.")
    elif token:
        print("\nAuthentication successful. Use the --update flag to send stats.")
        # Only print a snippet of the token
        print(f"Token Retrieved: {token[:4]}...{token[-4:]}")


if __name__ == '__main__':
    main()
